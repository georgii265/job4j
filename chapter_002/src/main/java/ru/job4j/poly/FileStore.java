package ru.job4j.poly;

/**
 * extends это ключевое слово, предназначенное для расширения реализации какого-то существующего класса.
 * Создается новый класс на основе существующего, и этот новый класс расширяет (extends) возможности старого.
 * В нашем примере класс FileStore расширяет класс DbStore(class FileStore extends DbStore).
 *
 * После того когда мы создали interface Store мы class FileStore implements Store.
 */
public class FileStore implements Store {

    /**
     * @Override указывает, что далее мы собираемся переопределять метод базового класса.
     *  Аннотация служит лишь для контроля успешности действия при сборке проекта.
     *
     *  В случае отсутствия данной аннотации и не совпадении сигнатур (в результате ошибки) с методом,
     *  который мы собирались переопределять - случится страшное - очень трудноуловимая ошибка,
     *  когда вы думаете, что должно бы переопределяться, а по факту имеете отдельный независимый метод,
     *  который скорее всего вообще не выполняется. При этом компилятор считает,
     *  что с его точки зрения все в порядке - хотите собственный метод в классе-наследнике - нет проблем. И молчит
     * @param values
     */
    @Override
    public void save(String values) {
       // super.save(values);
    }

    /**
     * Ключевое слово super в Java используется когда подклассу требуется сослаться на его непосредственный суперкласс.
     * У ключевого слова super имеются две общие формы:
     * Для вызова конструктора суперкласса: например - super.save(value);
     * Для обращения к члену суперкласса, скрываемому членом подкласса: например - super.load();
     *
     * После того когда мы создали interface Store мы class FileStore implements Store.
     * У нас нет необходимости в методе super.
     * Теперь хранилища не привязаны друг к другу.
     * @return
     */
    @Override
    public String [] load() {
        //return super.load();
        return new String[0];
    }
}